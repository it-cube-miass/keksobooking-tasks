## Цель задания
В этом задании наша цель научиться генерировать моки и воспользоваться шаблонизацией для отрисовки их в разметку страницы.

Моки — это не настоящие данные, но идентичные по своей структуре оригинальным. Например, сервер с которого можно взять реальные данные ещё не запущен, но это не повод тормозить процесс разработки front-end. Если есть соглашение о структуре данных, то ничего не мешает самостоятельно сгенерировать данные в нужном виде и использовать их для тестирования. Когда появится реальный сервер достаточно будет внести несколько небольших изменений и переключиться на применение реальных данных.

## Задача
Отобразить похожие объявления на карте.

Для этого:

1. Напишите функцию для создания массива из 8 сгенерированных JS объектов. Каждый объект массива ‐ описание похожего объявления неподалёку. Структура объектов должна быть следующей:
```javascript
{
    "author": {
        "avatar": строка, адрес изображения вида img/avatars/user{{xx}}.png, где {{xx}} это число от 1 до 8 с ведущим нулём. Например, 01, 02 и т. д. Адреса изображений не повторяются
    },
    "offer": {
        "title": строка, заголовок предложения
        "address": строка, адрес предложения. Для простоты пусть пока представляет собой запись вида "{{location.x}}, {{location.y}}", например, "600, 350"
        "price": число, стоимость
        "type": строка с одним из четырёх фиксированных значений: palace, flat, house или bungalow
        "rooms": число, количество комнат
        "guests": число, количество гостей, которое можно разместить
        "checkin": строка с одним из трёх фиксированных значений: 12:00, 13:00 или 14:00,
        "checkout": строка с одним из трёх фиксированных значений: 12:00, 13:00 или 14:00
        "features": массив строк случайной длины из ниже предложенных: "wifi", "dishwasher", "parking", "washer", "elevator", "conditioner",
        "description": строка с описанием,
        "photos": массив строк случайной длины, содержащий адреса фотографий "http://o0.github.io/assets/images/tokyo/hotel1.jpg", "http://o0.github.io/assets/images/tokyo/hotel2.jpg", "http://o0.github.io/assets/images/tokyo/hotel3.jpg"
    },
    "location": {
        "x": случайное число, координата x метки на карте. Значение ограничено размерами блока, в котором перетаскивается метка.
        "y": случайное число, координата y метки на карте от 130 до 630.
    }
}
```

> Для заголовка (```title```) можно использовать следующий список
```javascript
const TITLES = [
  'Большая уютная квартира',
  'Маленькая неуютная квартира',
  'Огромный прекрасный дворец',
  'Маленький ужасный дворец',
  'Красивый гостевой домик',
  'Некрасивый негостеприимный домик',
  'Уютное бунгало далеко от моря',
  'Неуютное бунгало по колено в воде',
];
```

2. У блока ```.map``` уберите класс ```.map--faded```
> Это временное решение, этот класс переключает карту из неактивного состояния в активное. В последующих заданиях, в соответствии с ТЗ вы будете переключать режимы страницы: неактивный, в котором карта и форма заблокированы и активный режим, в котором производится ввод данных и просмотр похожих объявлений. Сейчас для тестирования функции генерации похожих объявлений мы временно сымитируем активный режим, а в последующих разделах запрограммируем его полностью.

3. На основе данных, созданных в первом пункте, создайте DOM-элементы, соответствующие меткам на карте, и заполните их данными из массива. Итоговую разметку метки ```.map__pin``` можно взять из шаблона ```#pin```.

У метки укажите:

Координаты: ```style="left: {{location.x + смещение по X}}px; top: {{location.y + смещение по Y}}px;"```

> Обратите внимание. Координаты X и Y, которые вы вставите в разметку, это не координаты левого верхнего угла блока метки, а координаты, на которые указывает метка своим острым концом. Чтобы найти эту координату нужно учесть размеры элемента с меткой.

У изображения метки укажите:
* Аватар: ```src="{{author.avatar}}"```
* Альтернативный текст: ```alt="{{заголовок объявления}}"```

4. Отрисуйте сгенерированные DOM-элементы в блок ```.map__pins.``` Для вставки элементов используйте ```DocumentFragment```.
